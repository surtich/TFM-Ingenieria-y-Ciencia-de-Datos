## Modelado Bayesiano.

En el apéndice se comparan diversas parametrizaciones de modelado bayesiano utilizando la función `brm()` del paquete `brms`. Analizamos aquí la que mejor resultado resultado produjo en la aproximación bayesiana a validación cruzada `leave-one-out`:

\scriptsize
```{r}
#| echo: true
#| cache: true
brm_treat.period.subject.question <- brm(
    Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question),
    data = df_clean,
    family = cumulative("logit"),
    sample_prior = TRUE,
    file = "models/brm_treat.period.subject.question",
    file_refit = "on_change"
)
```
\normalsize

Esta parametrización coincide con la que elegimos en el apartado de Regresión Ordinal con efectos mixtos. El modelo utiliza como factores con efectos fijos (`complete pooling` en terminología bayesiana) el nivel de subtitulado y el periodo y la interacción entre ambos; y como efectos aleatorios (`partial pooling`) los sujetos y las preguntas del test. Cada uno de ellos con un intercepto y un nivel de subtitulado variable. El resumen del modelo es el siguiente:

\scriptsize
```{r}
#| echo: true
summary(brm_treat.period.subject.question)
```
\normalsize

En el @tbl-model-comp se comparan las estimaciones puntuales que obtuvimos para este modelo con la función `clmm`. Se comprueba que son muy similares. También se añaden los intervalos de confianza. Vemos que los interceptores son claramente significativos y también el coeficiente de `TreatB`. Sin embargo los coeficientes correspondientes al efecto periodo, `Period2`, y al efecto secuencia, `TreatB:Period`, incluyen el cero y además tienen intervalos muy grandes por lo que hay mucha incertidumbre respecto a su verdadero valor.  

\tiny
```{r}
#| label: tbl-model-comp
#| tbl-cap: Comparación frecuentista/bayesiano de coeficientes estimados en el modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
#| cache: true
df_clmm <- coef(clmm_treat.period.subject.question) %>% data.frame() #|
colnames(df_clmm) <- c("Estimation.clmm")

df_clmm <- bind_cols(df_clmm, confint(clmm_treat.period.subject.question))

df_clmm_ranef_coefs <- c(
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "stddev")[1],
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "stddev")[2],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "stddev")[1],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "stddev")[2],
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "correlation")[2, 1],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "correlation")[2, 1]
) %>% data.frame()

rownames(df_clmm_ranef_coefs) <- c("Subject.sd(Intercept)", "Subject.sd(TreatB)", "Subject.cor(Intercept,TreatB)", "Question.sd(Intercept)", "Question.sd(TreatB)", "Question.cor(Intercept,TreatB)")
colnames(df_clmm_ranef_coefs) <- c("Estimation.clmm")

df_clmm <- bind_rows(df_clmm, df_clmm_ranef_coefs)
df_brm <- (broom.mixed::tidyMCMC(brm_treat.period.subject.question, conf.int = T))[1:13, ]

colnames(df_clmm) <- c("Estimation.clmm", "2.5%", "97.5%")
colnames(df_brm) <- c("Name", "Estimation.brm", "std.error", "conf.low", "conf.high")
df_brm$Name <- rownames(df_clmm)
df_clmm$Name <- df_brm$Name
df_clmm <- df_clmm %>% tibble()

left_join(df_clmm, df_brm) %>%
    relocate(Name) %>%
    mutate(across(where(is.numeric), ~ round(., 2))) %>%
    gt() %>%
    tab_spanner(
        label = "ordinal::clmm",
        columns = c(Estimation.clmm, `2.5%`, `97.5%`)
    ) %>%
    tab_spanner(
        label = "brms::brm",
        columns = c(Estimation.brm, std.error, conf.low, conf.high)
    ) %>%
    sub_missing(columns = everything(), missing_text = "") %>%
    tab_options(table.font.size = 6)
```
\normalsize

No hemos dado valor a las distribuciones de probabilidad a priori con fiando que los valores por defecto que asigna `brm` son adecuados. En el @tbl-priors se muestran las distribuciones a priori de los parámetros aleatorios del modelo. En la @fig-priors se constata que toman valores razonables y no informativos.

\tiny
```{r}
#| label: tbl-priors
#| tbl-cap: Distribuciones a priori del modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
#| cache: true
prior_summary(brm_treat.period.subject.question) %>%
    gt() %>%
    tab_options(table.font.size = 8)
```
\normalsize

```{r}
#| label: fig-priors
#| fig-cap: Distribuciones a priori del modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
prior_draws(brm_treat.period.subject.question) %>%
    pivot_longer(cols = everything(), names_to = "term", values_to = "value") %>%
    ggplot(aes(x = value, y = term, fill = term)) +
    geom_violin() +
    labs(y = NULL) +
    coord_cartesian(xlim = c(-7.5, 7.5)) +
    theme(legend.position = "none")
```

Es importante asegurar que el entrenamiento del a convergido a su distribución a posteriori. En la tabla de resumen constatamos que el valor de `Rhat` es inferior a 1.1 y el de `ESS` superior a 400 en todos los parámetros, que son umbrales que no se deberían violar [@ver @burkner2019]. En la
 @fig-trace se comprueba que las cadenas de muestrado se mezclan correctamente y no muestran autocorrelación en ninguno de las parámetros. Por último, en la @fig-predictive se muestra un a comparación de los histogramas obtenidos de modelo con los intervalos de confianza marginales de la función predictiva a posteriori del modelo. En la mayoría de las preguntas, el muestreo reproduce bastante bien el histograma en casi todas las preguntas excepto en algunas como la `Q16` o la `Q17`.
```{r}
#| label: fig-trace
#| fig-cap: MCMC trazado del modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
#| cache: true
#| fig-height: 10
mcmc_plot(brm_treat.period.subject.question, type = "trace")
```

```{r}
#| label: fig-predictive
#| fig-cap: Comparación de los valores reales con los obtenidos a partir de la función predictiva a posteriori del modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
#| fig-height: 10
pp_check(brm_treat.period.subject.question, type = "bars_grouped", group = "Question", ndraws = 1000)
```
