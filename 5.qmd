```{r}
source("_setup.R")
```

# Resultados {#sec-resultados}

En esté capítulo se comentarán los resultados de las técnicas estadísticas y de los modelos propuestos (ver @sec-modelado).


### Correlación entre preguntas con el alfa de Cronbach {#sec-cronbach-2}

\scriptsize
```{r}
alpha <- df_all %>%
    pivot_wider(
        names_from = Question,
        values_from = Response_v,
        id_cols = c(Treat, Subject)
    ) %>%
    dplyr::select(-c(Treat, Subject)) %>%
    psych::alpha()
```
\normalsize


El coeficiente `alfa de Cronbach` (ver @sec-cronbach) de la escala de Likert es `r formatC(alpha$total[[1]], 3)` lo que indica una muy buena correlación entre las respuestas a todas las preguntas. Este valor apenas se ve alterado si se elimina una de las preguntas. Esto nos permite concluir que todos los ítems pertenecen a la misma escala de Likert. En la @tbl-item-alpha mostramos las preguntas que más contribuyen al índice `alpha de Cronbach`. Un resultado interesante es constatar que la pregunta $Q18$, que es la valoración general del cuestionario, es la que mejor contribución tiene al índice.

\tiny
```{r}
#| label: tbl-item-alpha
#| tbl-cap: Relación de cada pregunta con el índice alpha de Cronbach.
#| tbl-subcap:
#|   - "Variables con mayor asociación."
#|   - "Variables con menor asociación."
alpha.item <- alpha$item.stats[2] %>%
    arrange(desc(raw.r)) %>%
    t() %>%
    data.frame() %>%
    round(2)
alpha.item[1:9] %>%
    gt() %>%
    tab_options(table.font.size = 6)
alpha.item[10:18] %>%
    gt() %>%
    tab_options(table.font.size = 6)
```
\normalsize


### Asociación de variables con la prueba de homogeneidad $\chi^2$ {#sec-chi2-2}

En la @sec-chi2 se describe el marco teórico de esta prueba no paramétrica. Se ha contrastado la existencia de asociación entre la variable respuesta $Response$ y cada una de las tres variables más importantes de nuestro modelo ($Treat$, $Period$ y $Seq$). En la @tbl-contingencia-2 se muestran las tablas de contingencia. La @tbl-chi2 permite comprobar que todos los contrastes son significativos, con lo que se rechaza la hipótesis nula de homogeneidad. Todas las variables explicativas tienen influencia en la variable respuesta.

```{r}
#| label: tbl-contingencia-2
#| tbl-cap: Tablas de contingencia.
#| tbl-subcap:
#|   - "~ Response + Treat"
#|   - "~ Response + Period"
#|   - "~ Response + Seq"
#| layout-ncol: 3

xtabs(~ Response + Treat, data = df_clean) %>%
    data.frame() %>%
    pivot_wider(names_from = Treat, values_from = Freq) %>%
    knitr::kable()
xtabs(~ Response + Period, data = df_clean) %>% knitr::kable()
xtabs(~ Response + Seq, data = df_clean) %>% knitr::kable()
```

```{r}
chi1 <- chisq.test(df_all$Treat, df_all$Response)
chi2 <- chisq.test(df_all$Period, df_all$Response)
chi3 <- chisq.test(df_all$Seq, df_all$Response)
```


|           | ~ Response + Treat          | ~ Response + Period          | ~ Response + Seq             |
|-----------|----------------------------:|-----------------------------:|-----------------------------:|
| $\chi^2$  | `r round(chi1$statistic,3)` | `r round(chi2$statistic,3)`  | `r round(chi3$statistic,3)`  |
| $p$-value | `r chi1$p.value`            | `r chi2$p.value`             | `r chi3$p.value`             |
| $df$      | `r chi1$parameter`          | `r chi2$parameter`           | `r chi3$parameter`           |

: Valores del contraste de hipótesis $\chi^2$ {#tbl-chi2}

### Comparación con $Odds\ Ratio$ {#sec-or-3}

En @sec-or y en @sec-or-2 se exponen el marco teórico y la fundamentación de los contrastes de hipótesis realizados respectivamente. El contraste de hipótesis del $log\ OR$ del subtitulado para cada grupo no produce significación estadística en ningún nivel de respuesta, por lo que según esta prueba estadística la secuencia de subtitulado no influiría en la respuesta de los estudiantes (ver @tbl-logor1). Es decir, de acuerdo a este test la secuencia no influye en la valoración de los subtítulos.

```{r}
#| label: tbl-logor1
#| tbl-cap: $Log\ OR$ ~ Treat + Seq + Response_l
data.frame(summary(loddsratio(~ Treat + Seq + Response_l, data = df_all)) %>% unclass(), check.names = F) %>%
    rownames_to_column("Response") %>%
    mutate_if(is.numeric, round, 3) %>%
    gt()
```

Sin embargo, si realizamos este contraste entre subtítulos y periodos podemos constatar la existencia de un efecto periodo de signo contrario para las preguntas 4 y 5 (ver @tbl-logor2). 

```{r}
#| label: tbl-logor2
#| tbl-cap: Log OR ~ Treat + Period + Response_l
data.frame(summary(loddsratio(~ Treat + Period + Response_l, data = df_all)) %>% unclass(), check.names = F) %>%
    rownames_to_column("Response") %>%
    mutate_if(is.numeric, round, 3) %>%
    gt()
```

### Modelado

```{r}
options(contrasts = rep("contr.sum", 2))
glmer_improve_subject_question <- glmer(Improve ~ 1 + (1 | Subject) + (1 | Question), family = "binomial", data = df_improve)

improve_question <- 1 / (1 + exp(-coef(glmer_improve_subject_question)$Question + fixef(glmer_improve_subject_question)))

improve_question <- cbind(rownames(improve_question), improve_question)
colnames(improve_question) <- c("Question", "Prob")

# summary(glmer_improve_subject_question)
```

El modelo de efectos mixtos ajustado con Regresión Logística:

> Improve ~ 1 + (1 | Subject) + (1 | Question)

estima la probabilidad de que la respuesta a un ítem en el subtitulado $A$ sea mejor que en el subtitulado $B$ frente a que sea igual o peor.
El intercepto del modelo ajustado es `r round(fixef(glmer_improve_subject_question)[[1]],3)`. Por ello, la probabilidad de que se otorgue una mayor puntuación en $A$ que en $B$ es del `r paste(round(100/(1+exp(-fixef(glmer_improve_subject_question)[[1]])),2),"%", sep="")`. En la @tbl-improve-question se muestra la probabilidad de que la respuesta sea mejor en $A$ que en $B$ por ítem.

\scriptsize
```{r}
#| label: tbl-improve-question
#| tbl-cap: Probabilidad de que la respuesta a un ítem sea A > B frente a A <= B
improve_question %>%
    gt() %>%
    fmt_number(Prob, decimals = 2)
```

\normalsize

En la @sec-ordinal-2 se evaluaron distintas parametrizaciones de la Regresión Ordinal Acumulativa tanto desde el punto de vista frecuentista como bayesiano y considerando únicamente efectos fijos y también efectos aleatorios. Finalmente, tanto en el análisis frecuentista como en el bayesiano, el modelo que resultó ser más parsimonioso es el de la @eq-mejor-modelo, que se reproduce aquí en sintaxis R:

\small
> Response ~ Treat*Period + (1 + Treat  | Subject) + (1 + Treat | Question)
\normalsize


Este modelo produce en los dos paradigmas unas estimaciones similares, como se puede comprobar en la @tbl-model-comp.


```{r}
#| cache: true
options(contrasts = rep("contr.sum", 2))

clmm_treat.period.subject.question <- clmm(
    Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question),
    data = df_clean
)

brm_treat.period.subject.question <- brm(
    Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question),
    data = df_clean,
    family = cumulative("logit"),
    iter = 4000,
    sample_prior = TRUE,
    file = "models/brm_treat.period.subject.question",
    file_refit = "on_change"
)
```


\tiny
```{r}
#| label: tbl-model-comp
#| tbl-cap: Comparación frecuentista/bayesiano de coeficientes estimados en el modelo Response ~ Treat * Period + (1 + Treat | Subject) + (1 + Treat | Question).
#| cache: true
df_clmm <- coef(clmm_treat.period.subject.question) %>% data.frame()
colnames(df_clmm) <- c("Estimation.clmm")

df_clmm <- bind_cols(df_clmm, confint(clmm_treat.period.subject.question))

df_clmm_ranef_coefs <- c(
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "stddev")[1],
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "stddev")[2],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "stddev")[1],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "stddev")[2],
    attr(VarCorr(clmm_treat.period.subject.question)$Question, "correlation")[2, 1],
    attr(VarCorr(clmm_treat.period.subject.question)$Subject, "correlation")[2, 1]
) %>% data.frame()

rownames(df_clmm_ranef_coefs) <- c("Question.sd(Intercept)", "Question.sd(Treat1)", "Subject.sd(Intercept)", "Subject.sd(Treat1)", "Question.cor(Intercept,Treat1)", "Subject.cor(Intercept,Treat1)")
colnames(df_clmm_ranef_coefs) <- c("Estimation.clmm")

df_clmm <- bind_rows(df_clmm, df_clmm_ranef_coefs)
df_brm <- (broom.mixed::tidyMCMC(brm_treat.period.subject.question, conf.int = T))[1:13, ]

colnames(df_clmm) <- c("Estimation.clmm", "conf.2.5%", "conf.97.5%")
colnames(df_brm) <- c("Name", "Estimation.brm", "std.error", "cred.2.5%", "cred.97.5%")
df_brm$Name <- rownames(df_clmm)
df_clmm$Name <- df_brm$Name
df_clmm <- df_clmm %>% tibble()

left_join(df_clmm, df_brm) %>%
    relocate(Name) %>%
    mutate(across(where(is.numeric), ~ round(., 2))) %>%
    select(-c("std.error")) %>%
    gt() %>%
    tab_spanner(
        label = "ordinal::clmm",
        columns = c(Estimation.clmm, `conf.2.5%`, `conf.97.5%`)
    ) %>%
    tab_spanner(
        label = "brms::brm",
        columns = c(Estimation.brm, `cred.2.5%`, `cred.97.5%`)
    ) %>%
    sub_missing(columns = everything(), missing_text = "") %>%
    tab_options(table.font.size = 6)
```
\normalsize



{{< include 6.qmd >}}

